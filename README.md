# Классификация сокращений сердца на базе MIT-BIH (ECG Classification)

## Постановка задачи

По данным записи электрокардиограммы определить отсутствие или наличие аритмии из следующего списка:

1. N (Normal): Нормальный ритм и нормальные сокращения.

1. S (Supraventricular): Наджелудочковые эктопические сокращения.

1. V (Ventricular): Желудочковые сокращения.

1. F (Fusion): Сливные сокращения (комбинация нормального и желудочкового импульсов).

1. Q (Unknown/Paced): Неизвестные типы сокращений или работа кардиостимулятора.

## Формат входных и выходных данных

Входные данные: два файла записи электрокардиограммы в формате _.hea и _.dat с количеством отведений от 1 до 2.

Выходные данные: текстовые данные результата поиска аритмии (Normal, Supraventricular, Ventricular, Fusion, Unknown).

1. Смысловое содержание проекта

Цель проекта — создание инструмента поддержки принятия решений (DSS) для кардиологов. Модель анализирует морфологию сигнала ЭКГ и классифицирует каждый удар сердца по пяти категориям аритмий (стандарт AAMI):

N (Normal): Нормальный ритм и нормальные сокращения.

S (Supraventricular): Наджелудочковые эктопические сокращения.

V (Ventricular): Желудочковые сокращения (наиболее опасные патологические состояния).

F (Fusion): Сливные сокращения (комбинация нормального и желудочкового импульсов).

Q (Unknown/Paced): Неизвестные типы сокращений или работа кардиостимулятора.

Проект не ставит окончательный клинический диагноз, а подсвечивает патологические события для последующего анализа врачом.

2. Setup (Настройка окружения)

Проект использует современный менеджер пакетов uv для управления зависимостями и виртуальным окружением.

Предварительные требования

Python версии 3.10 или выше.

Установленный инструмент uv (pip install uv).

Инструкция по развертыванию

Клонирование репозитория:

git clone <url*вашего*репозитория>
cd deep_ecg_2025

Создание окружения и установка зависимостей:

uv sync

Активация окружения:

Windows: .venv\Scripts\activate

Linux/macOS: source .venv/bin/activate

Настройка инструментов качества кода:

uv run pre-commit install

3. Train (Обучение)

Процесс обучения разделен на этапы подготовки данных и запуска тренировочного цикла. Конфигурация осуществляется через Hydra.

Этап 1: Препроцессинг и синхронизация (DVC)

Скрипт preprocess.py выполняет следующие действия:

Синхронизирует сырые данные с удаленным хранилищем (dvc pull).

Извлекает сегменты сигнала вокруг R-пиков (окно 187 отсчетов).

Нормализует амплитуду сигнала в диапазон [0, 1].

Сохраняет обработанные тензоры в data/processed/.

Запуск:

uv run python src/preprocess.py

Этап 2: Тренировка модели

Запуск основного цикла обучения с использованием PyTorch Lightning и логированием в MLflow.
Запуск:

uv run python src/train.py

Для работы логирования предварительно запустите сервер MLflow:

mlflow server --port 8080

4. Production Preparation

Для использования модели в реальных приложениях предусмотрена процедура экспорта.

Экспорт в ONNX: Модель автоматически конвертируется в формат ONNX после завершения обучения (или через скрипт export.py).

Файл: models/ecg_model.onnx

Преимущества: Высокая скорость инференса и отсутствие зависимости от PyTorch.

Комплектация поставки:

Обученные веса: models/ecg_model.onnx

Карта классов (label_map): configs/preprocess/default.yaml

5. Infer (Предсказание)

Скрипт инференса работает на базе onnxruntime, что позволяет запускать предсказания с минимальным количеством зависимостей.

Формат входных данных

Модель ожидает массив NumPy (или тензор) размерностью (1, 1, 187), где 187 — отсчеты сигнала, нормализованные от 0 до 1.

Пример запуска

uv run python src/infer.py --input_path data/test_samples/sample_v.npy

6. Логирование и результаты

В соответствии с требованиями, в проекте сохраняются следующие артефакты:

Графики: В директории plots/ находятся актуальные кривые Loss и Accuracy.

MLflow: В интерфейсе доступны гиперпараметры, метрики и Git Commit ID каждого запуска.
